<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Johnny Jumper: Shop Edition 2026</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a0f00; font-family: 'Arial Black', sans-serif; color: #fff; }
        canvas { display: block; background: linear-gradient(#4facfe 0%, #00f2fe 100%); margin: auto; border: 6px solid #3e2723; }
        
        #ui { position: absolute; top: 15px; width: 100%; text-align: center; pointer-events: none; font-size: 28px; text-shadow: 3px 3px #000; z-index: 10; }
        
        .menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                background: #3e2723; padding: 30px; border: 5px solid #fdd835; text-align: center; 
                border-radius: 20px; z-index: 100; min-width: 300px; }
        
        button { background: #fdd835; border: none; padding: 12px 25px; font-weight: bold; cursor: pointer; 
                font-size: 18px; border-radius: 8px; margin: 10px; transition: 0.2s; }
        button:hover { transform: scale(1.05); background: #fff; }
        
        .shop-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 20px; }
        .skin-item { border: 2px solid #fff; padding: 10px; cursor: pointer; border-radius: 10px; }
        .skin-item:hover { background: rgba(255,255,255,0.1); }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="ui">Level: <span id="lvl-txt">1</span> | ðŸ’€ Tode: <span id="death-txt">0</span></div>

<!-- HauptmenÃ¼ -->
<div id="main-menu" class="menu">
    <h1>ðŸ¤  JOHNNY JUMPER ðŸ¤ </h1>
    <button onclick="startGame()">JETZT SPIELEN</button><br>
    <button onclick="openShop()">ZUM SKIN-SHOP</button>
</div>

<!-- Shop -->
<div id="skin-shop" class="menu hidden">
    <h1>KLARENS GARDEROBE</h1>
    <p>WÃ¤hle einen gratis Skin:</p>
    <div class="shop-grid" id="shop-list"></div>
    <br>
    <button onclick="closeShop()">ZURÃœCK ZUM MENÃœ</button>
</div>

<!-- Game Over -->
<div id="game-over" class="menu hidden">
    <h1 style="color: #ff5252;">DAS WAR'S, PARTNER!</h1>
    <p>Tode in diesem Versuch: <span id="death-count-over">0</span></p>
    <button onclick="restartLevel()">ERNEUTER VERSUCH</button>
    <button onclick="backToMenu()">HAUPTMENÃœ</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 1100;
canvas.height = 600;

const GRAVITY = 0.7;
const FRICTION = 0.85;
const JUMP_FORCE = -16.5;

let currentLevel = 1;
let deaths = 0;
let gameState = 'MENU';
let keys = {};
let cameraX = 0;

let player = { 
    x: 100, y: 100, w: 35, h: 50, vx: 0, vy: 0, 
    grounded: false, inWater: false, onBelt: 0, ice: false,
    color: '#fdd835', shape: 'rect'
};

let platforms = [];
let entities = [];

const skins = [
    { name: "Default", color: "#fdd835", shape: "rect" },
    { name: "Ghost", color: "#fff", shape: "rect" },
    { name: "Slime", color: "#00ff00", shape: "circle" },
    { name: "Goldy", color: "#f1c40f", shape: "star" },
    { name: "Shadow", color: "#333", shape: "rect" },
    { name: "Berry", color: "#e91e63", shape: "circle" }
];

const themes = ['normal', 'ice', 'belt_left', 'belt_right', 'trampoline', 'falling', 'waterfall'];

function setupLevel(lvl) {
    platforms = []; entities = [];
    cameraX = 0;
    player.x = 100; player.y = 300; player.vx = 0; player.vy = 0;

    platforms.push({ x: 0, y: 450, w: 400, h: 300, type: 'normal' });

    if (lvl % 10 === 0) { setupBoss(lvl); return; }

    let lastP = platforms;
    for (let i = 0; i < 15 + lvl; i++) {
        let type = themes[Math.floor(Math.random() * themes.length)];
        let gapX = 110 + Math.random() * 90; 
        let diffY = (Math.random() * 100) - 50; 
        
        let nX = lastP.x + lastP.w + gapX;
        let nY = Math.max(180, Math.min(500, lastP.y + diffY));
        let nW = 150 + Math.random() * 100;

        // Wasserfall geht von oben (0) bis unten (600)
        if(type === 'waterfall') nW = 80;

        platforms.push({ x: nX, y: type === 'waterfall' ? 0 : nY, w: nW, h: type === 'waterfall' ? 1000 : 40, type: type, realY: nY });
        
        if (lvl > 3 && Math.random() > 0.8 && type !== 'waterfall') {
            entities.push({ x: nX + 20, y: nY - 35, type: 'cannon', cd: 0 });
        }
        lastP = platforms[platforms.length-1];
    }
    platforms.push({ x: lastP.x + lastP.w + 150, y: 350, w: 200, h: 350, type: 'goal' });
}

function setupBoss(lvl) {
    platforms.push({ x: 500, y: 450, w: 800, h: 50, type: 'normal' });
    entities.push({ x: 1000, y: 200, w: 120, h: 120, type: 'boss', hp: 3 + (lvl/10), cd: 0 });
    platforms.push({ x: 1600, y: 350, w: 100, h: 350, type: 'goal' });
}

function update() {
    if (gameState !== 'PLAY') return;

    if (keys['ArrowRight'] || keys['KeyD']) player.vx += 1.0;
    if (keys['ArrowLeft'] || keys['KeyA']) player.vx -= 1.0;
    player.vx *= (player.ice ? 0.98 : FRICTION);
    
    if (player.inWater) {
        player.vy = 1.5; 
        if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) player.vy = -7;
    } else {
        player.vy += GRAVITY;
    }
    
    player.x += player.vx + player.onBelt;

    let steps = 5;
    player.grounded = false;
    player.inWater = false;
    player.onBelt = 0;
    player.ice = false;

    for (let s = 0; s < steps; s++) {
        player.y += player.vy / steps;
        
        for (let p of platforms) {
            if (player.x + player.w > p.x && player.x < p.x + p.w && player.y + player.h > p.y && player.y < p.y + p.h) {
                
                if (p.type === 'waterfall') {
                    player.inWater = true;
                    continue; 
                }
                
                // Landung
                if (player.vy >= 0 && player.y + player.h <= p.y + 20) {
                    player.y = p.y - player.h;
                    player.vy = 0;
                    player.grounded = true;
                    if (p.type === 'ice') player.ice = true;
                    if (p.type === 'belt_right') player.onBelt = 4;
                    if (p.type === 'belt_left') player.onBelt = -4;
                    if (p.type === 'trampoline') { player.vy = JUMP_FORCE * 1.6; player.grounded = false; }
                    if (p.type === 'falling') p.y += 3;
                    if (p.type === 'goal') nextLevel();
                }
            }
        }
    }

    if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.grounded && !player.inWater) {
        player.vy = JUMP_FORCE;
    }

    cameraX = Math.max(cameraX, player.x - 300);
    if (player.y > canvas.height + 100) die();

    entities.forEach((e, i) => {
        if (e.type === 'cannon') {
            e.cd++; if(e.cd > 110) { entities.push({x: e.x, y: e.y, vx: -7, type: 'bullet'}); e.cd = 0; }
        }
        if (e.type === 'bullet') { e.x += e.vx; if (rectHit(player, e)) die(); }
        if (e.type === 'boss') {
            e.y = 150 + Math.sin(Date.now()/600) * 100;
            e.cd++; if(e.cd > 70) { entities.push({x: e.x, y: e.y + 50, vx: -6, type: 'bullet'}); e.cd = 0; }
            if (player.vy > 0 && rectHit(player, e)) { e.hp--; player.vy = -15; if(e.hp <= 0) entities.splice(i, 1); }
            else if (rectHit(player, e)) die();
        }
    });
}

function rectHit(a, b) { return a.x < b.x + (b.w||10) && a.x + a.w > b.x && a.y < b.y + (b.h||10) && a.y + a.h > b.y; }

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save(); ctx.translate(-cameraX, 0);

    platforms.forEach(p => {
        if (p.type === 'waterfall') {
            ctx.fillStyle = 'rgba(0, 180, 255, 0.4)';
            ctx.fillRect(p.x, 0, p.w, canvas.height);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            for(let j=0; j<2; j++) ctx.fillRect(p.x + (j*30) + 10, (Date.now()/5)%canvas.height, 4, 40);
        } else {
            ctx.fillStyle = p.type === 'ice' ? '#81d4fa' : (p.type === 'trampoline' ? '#f06292' : (p.type === 'goal' ? '#4caf50' : '#5d4037'));
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.strokeStyle = '#fff'; ctx.strokeRect(p.x, p.y, p.w, p.h);
        }
    });

    entities.forEach(e => {
        if (e.type === 'boss') { ctx.fillStyle = '#000'; ctx.fillRect(e.x, e.y, e.w, e.h); }
        if (e.type === 'bullet') { ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(e.x, e.y, 8, 0, Math.PI*2); ctx.fill(); }
        if (e.type === 'cannon') { ctx.fillStyle = '#212121'; ctx.fillRect(e.x, e.y, 35, 35); }
    });

    ctx.fillStyle = player.color;
    if (player.shape === 'circle') {
        ctx.beginPath(); ctx.arc(player.x + player.w/2, player.y + player.h/2, player.w/2, 0, Math.PI*2); ctx.fill();
    } else if (player.shape === 'star') {
        drawStar(player.x + player.w/2, player.y + player.h/2, 5, 25, 10);
    } else {
        ctx.fillRect(player.x, player.y, player.w, player.h);
    }
    
    ctx.fillStyle = '#3e2723';
    ctx.fillRect(player.x-5, player.y, player.w+10, 10);
    ctx.fillRect(player.x+5, player.y-10, player.w-10, 10);

    ctx.restore();
}

function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3; let x = cx; let y = cy; let step = Math.PI / spikes;
    ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
    for (i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y); rot += step; x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.fill();
}

function initShop() {
    const list = document.getElementById('shop-list');
    list.innerHTML = '';
    skins.forEach(s => {
        let item = document.createElement('div');
        item.className = 'skin-item';
        item.style.borderColor = s.color;
        item.innerHTML = `<div style="width:30px;height:30px;background:${s.color};margin:auto"></div><small>${s.name}</small>`;
        item.onclick = () => { player.color = s.color; player.shape = s.shape; alert(s.name + " ausgewÃ¤hlt!"); };
        list.appendChild(item);
    });
}

// UI LOGIK
function startGame() { 
    document.getElementById('main-menu').classList.add('hidden'); 
    gameState = 'PLAY'; 
    setupLevel(currentLevel); 
    requestAnimationFrame(gameLoop); 
}
function openShop() { document.getElementById('main-menu').classList.add('hidden'); document.getElementById('skin-shop').classList.remove('hidden'); }
function closeShop() { document.getElementById('skin-shop').classList.add('hidden'); document.getElementById('main-menu').classList.remove('hidden'); }
function die() { 
    deaths++; 
    document.getElementById('death-txt').innerText = deaths;
    document.getElementById('death-count-over').innerText = deaths;
    gameState = 'OVER'; 
    document.getElementById('game-over').classList.remove('hidden'); 
}
function nextLevel() { currentLevel++; document.getElementById('lvl-txt').innerText = currentLevel; setupLevel(currentLevel); }
function restartLevel() { document.getElementById('game-over').classList.add('hidden'); gameState = 'PLAY'; setupLevel(currentLevel); }
function backToMenu() { document.getElementById('game-over').classList.add('hidden'); document.getElementById('main-menu').classList.remove('hidden'); gameState = 'MENU'; }

function gameLoop() { 
    if (gameState === 'PLAY' || gameState === 'OVER') {
        update(); 
        draw(); 
        requestAnimationFrame(gameLoop); 
    }
}

window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

initShop();
</script>
</body>
</html>
